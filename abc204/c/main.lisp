(in-package :cl-user)

;;------------------------------Preferences------------------------------

(eval-when (:compile-toplevel :load-toplevel :execute)
  #+swank (declaim (optimize (speed 3) (safety 2)))
  #-swank (declaim (optimize (speed 3) (safety 0) (debug 0)))
  #+swank (load "~/Dropbox/Code/atcoder/ac-tools/act.lisp")
  #+swank (ql:quickload :prove)
  #-swank (declaim (sb-ext:muffle-conditions sb-ext:compiler-note))
  #-swank (sb-ext:disable-debugger)
  (pushnew :inline-generic-funcion *features*))

;;---------------------------------Body---------------------------------

(declaim (inline println))
(defun println (obj &optional (stream *standard-output*))
  (let ((*read-default-float-format* 'double-float))
    (prog1 obj
      (princ obj stream)
      (terpri stream))))

(defmacro with-gensyms ((&rest args) &body body)
  `(let ,(mapcar (lambda (arg) `(,arg (gensym))) args)
     ,@body))

(defmacro do-bfs ((&rest args) &body body)
  (with-gensyms (front tail empty-p pop!)
    (let ((vars (mapcar #'first args))
          (inits (mapcar #'second args))
          (types (mapcar #'third args)))
      `(let ((,front nil)
             (,tail nil))
         (declare (list ,front ,tail))
         (labels ((call (&rest args)
                    (push args ,tail))
                  (,empty-p ()
                    (and (null ,front)
                         (null ,tail)))
                  (,pop! ()
                    (when (null ,front)
                      (setf ,front (nreverse ,tail)
                            ,tail nil))
                    (pop ,front)))
           (declare (inline call ,empty-p ,pop!))
           (call ,@inits)
           (loop until (,empty-p)
                 for ,vars
                   of-type ,(or types (loop repeat (length args) collect t)) = (,pop!)
                 do ,@body))))))


(declaim (inline read-fixnum))
(defun read-fixnum (&optional (in *standard-input*))
  ;; Ref: https://competitive12.blogspot.com/2020/03/common-lisp.html
  ;;        partially modified
  (declare (inline read-byte))
  (flet ((%read-byte ()
           (the fixnum #+swank (char-code (read-char in nil #\Nul))
                       #-swank (read-byte in nil #.(char-code #\Nul))))
         (%byte->num (b)
           (the fixnum (- b #.(char-code #\0))))
         (%digit-p (byte)
           (declare (fixnum byte))
           (<= #.(char-code #\0) byte #.(char-code #\9))))
    (declare (inline %read-byte %byte->num %digit-p))
    (let ((minus nil)
          (res 0))
      (declare (boolean minus) (fixnum res))
      (loop for byte of-type fixnum = (%read-byte)
            do (cond
                 ((%digit-p byte)
                  (setf res (%byte->num byte))
                  (return))
                 ((= byte #.(char-code #\Nul))
                  (error "EOF"))
                 ((= byte #.(char-code #\-))
                  (setf minus t))))
      (loop for byte of-type fixnum = (%read-byte)
            do (cond
                 ((%digit-p byte)
                  (setf res (the fixnum (+ (* res 10) (%byte->num byte)))))
                 (t (return))))
      (the fixnum (if minus (- res) res)))))

(defun main ()
  (let* ((n (read))
         (m (read))
         (edges (make-array n :initial-element nil)))
    (dotimes (_ m)
      (let ((a (1- (read-fixnum)))
            (b (1- (read-fixnum))))
        (push b (aref edges a))))
    #+swank (println edges)
    (let ((res 0))
      (dotimes (start n)
        (let ((visited (make-array n :initial-element 0)))
          (do-bfs ((node start))
            (when (zerop (aref visited node))
              (setf (aref visited node) 1)
              (dolist (next (aref edges node))
                (when (zerop (aref visited next))
                  (call next)))))
          (incf res (reduce #'+ visited))))
      (println res))))

#-swank (main)
