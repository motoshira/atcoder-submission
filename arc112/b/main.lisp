(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *opt*
    #+swank '(optimize (speed 3) (safety 2))
    #-swank '(optimize (speed 3) (safety 0) (debug 0)))
  #+swank (load "~/Dropbox/Code/atcoder/ac-tools/act.lisp")
  #-swank (declaim (sb-ext:muffle-conditions sb-ext:compiler-note))
  #-swank (sb-ext:disable-debugger)
  (pushnew :inline-generic-funcion *features*))

(defmacro dbg (&rest forms)
  #-swank (declare (ignore forms))
  #+swank `(format *error-output* "~a => ~a~&" ',forms `(,,@forms)))

(defmacro do-rep (count &body body) `(loop repeat ,count do ,@body))

(defmacro nlet (name binds &body body)
  `(labels ((,name (,@(mapcar #'first binds))
              ,@body))
     (,name ,@(mapcar #'second binds))))

(defmacro dotimes! ((var count &optional (index-origin 0) (unroll 60)) &body body)
  (let ((cnt (gensym))
        (q (gensym))
        (r (gensym)))
    `(multiple-value-bind (,q ,r) (truncate ,count ,unroll)
       (declare (fixnum ,q ,r))
       (do ((,cnt 0 (the fixnum (1+ ,cnt))) (,var ,index-origin))
           ((>= ,cnt ,q) (loop repeat ,r do (progn ,@body (setf (the fixnum ,var) (the fixnum (1+ ,var))))))
         (declare (fixnum ,cnt ,var))
         ,@(loop repeat unroll append `(,@body (setf (the fixnum ,var) (the fixnum (1+ ,var)))))))))
 
(declaim (inline println))
(defun println (obj &optional (stream *standard-output*))
  (let ((*read-default-float-format* 'double-float))
    (prog1 obj
      (princ obj stream)
      (terpri))))

(defun read-nums (count &optional (element-type '(simple-array fixnum (*))))
  (declare (fixnum count))
  (coerce (loop repeat count collect (read)) element-type))

(define-modify-macro maxf (var) max)
(define-modify-macro minf (var) min)

(defun unite (&rest lists)
  (dbg lists)
  (nlet rec ((lists (sort (remove-if (lambda (xs)
                                       (or (null xs)
                                           (> (first xs)
                                              (second xs))))
                                     lists)
                          (lambda (xs ys)
                            (if (= (first xs) (first ys))
                                (< (second xs) (second ys))
                                (< (first xs) (first ys))))))
             (acc nil))
    (cond
      ((null lists) (reverse acc))
      ((or (null acc)
           (< (second (first acc))
              (first (first lists))))
       (rec (rest lists)
            (cons (first lists)
                  acc)))
      (t
       (destructuring-bind (l r) (first lists)
         (destructuring-bind (ll rr) (first acc)
           (rec (rest lists)
                (cons (list (min l ll) (max r rr))
                      (rest acc)))))))))

(defun main ()
  (declare #.*opt*)
  (let ((b (read))
        (c (read)))
    (declare (fixnum b c))
    (let ((lsts (unite
                 (list (- b (floor c 2))
                       b)
                 (when (>= c 2)
                   (list b (+ b (floor (- c 2) 2))))
                 (when (>= c 1)
                   (list (- (- b) (floor (max 0 (- c 1))
                                         2))
                         (- b)))
                 (when (>= (floor (1- c) 2) b)
                   (list (- b)
                         (- (- b (floor (1- c) 2))))))))
      (dbg lsts)
      (println (nlet rec ((xs lsts)
                          (res 0))
                 (dbg res)
                 (cond
                   ((null xs) res)
                   (t (destructuring-bind (l r) (first xs)
                        (rec (rest xs)
                             (+ res
                                (1+ (- r l))))))))))))

#-swank
(progn
  (setf (sb-alien:extern-alien "thread_control_stack_size" sb-kernel::os-vm-size-t)
        (* 256 1024 1024))
  (sb-thread:join-thread (sb-thread:make-thread #'main)))
